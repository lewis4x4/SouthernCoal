import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { PDFDocument, rgb, StandardFonts } from "https://esm.sh/pdf-lib@1.17.1";
import { corsHeaders } from "../_shared/cors.ts";

// ---------------------------------------------------------------------------
// Environment
// ---------------------------------------------------------------------------
const SUPABASE_URL = Deno.env.get("SUPABASE_URL") ?? "";
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";

// Disclaimer from Software_Disclaimer_and_Limitation_of_Liability.docx
const DISCLAIMER_ONELINER =
  "Generated by SCC Compliance Monitor — a compliance reporting tool. Not an EMS. Not legal or environmental consulting. All data and reports require independent verification by qualified personnel before regulatory submission.";

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------
interface CorrectiveActionRecord {
  id: string;
  organization_id: string;
  site_id: string | null;
  npdes_permit_id: string | null;
  smcra_permit_number: string | null;
  county: string | null;
  state: string | null;
  source_type: string;
  source_id: string | null;
  title: string;
  description: string | null;
  date_issued: string | null;
  date_received: string | null;
  issuing_person: string | null;
  issuing_agency: string | null;
  issued_to: string | null;
  regulation_cited: string | null;
  followup_assigned_to: string | null;
  contributing_factors: string | null;
  root_cause: string | null;
  immediate_mitigation: string | null;
  action_taken: string | null;
  preventive_action: string | null;
  documents_requiring_revision: string | null;
  effectiveness_assessment: string | null;
  workflow_step: string;
  status: string;
  priority: string;
  responsible_person_signed_at: string | null;
  approved_by_signed_at: string | null;
  created_at: string;
  // JOINed data
  organization?: { name: string };
  site?: { name: string };
  permit?: { permit_number: string };
  responsible_person?: { first_name: string; last_name: string };
  approved_by?: { first_name: string; last_name: string };
  followup_user?: { first_name: string; last_name: string };
}

// ---------------------------------------------------------------------------
// Auth verification
// ---------------------------------------------------------------------------
async function verifyAuth(
  req: Request,
  supabase: ReturnType<typeof createClient>
): Promise<{ userId: string | null; orgId: string | null }> {
  const authHeader = req.headers.get("Authorization");
  if (!authHeader?.startsWith("Bearer ")) {
    return { userId: null, orgId: null };
  }

  const token = authHeader.replace("Bearer ", "");
  const {
    data: { user },
    error,
  } = await supabase.auth.getUser(token);

  if (error || !user) {
    return { userId: null, orgId: null };
  }

  // Get user's org
  const { data: profile } = await supabase
    .from("user_profiles")
    .select("organization_id")
    .eq("id", user.id)
    .single();

  return { userId: user.id, orgId: profile?.organization_id ?? null };
}

// ---------------------------------------------------------------------------
// Fetch CA with all JOINs
// ---------------------------------------------------------------------------
async function fetchCorrectiveAction(
  supabase: ReturnType<typeof createClient>,
  caId: string
): Promise<CorrectiveActionRecord | null> {
  const { data, error } = await supabase
    .from("corrective_actions")
    .select(
      `
      *,
      organization:organizations(name),
      site:sites(name),
      permit:npdes_permits(permit_number),
      responsible_person:user_profiles!responsible_person_id(first_name, last_name),
      approved_by:user_profiles!approved_by_id(first_name, last_name),
      followup_user:user_profiles!followup_assigned_to(first_name, last_name)
    `
    )
    .eq("id", caId)
    .single();

  if (error) {
    console.error("[generate-ca-pdf] Fetch error:", error.message);
    return null;
  }

  return data as CorrectiveActionRecord;
}

// ---------------------------------------------------------------------------
// PDF Generation — Document 2015-013 layout
// ---------------------------------------------------------------------------
async function generatePdf(ca: CorrectiveActionRecord): Promise<Uint8Array> {
  const doc = await PDFDocument.create();
  const helvetica = await doc.embedFont(StandardFonts.Helvetica);
  const helveticaBold = await doc.embedFont(StandardFonts.HelveticaBold);

  const page = doc.addPage([612, 792]); // Letter size
  const { height } = page.getSize();

  let y = height - 50;
  const margin = 50;
  const lineHeight = 14;
  const sectionGap = 20;

  // Helper: draw section header
  const drawHeader = (text: string) => {
    page.drawText(text, {
      x: margin,
      y,
      size: 11,
      font: helveticaBold,
      color: rgb(0, 0, 0),
    });
    y -= lineHeight + 4;
  };

  // Helper: draw field
  const drawField = (label: string, value: string | null | undefined) => {
    const displayValue = value ?? "N/A";
    page.drawText(`${label}: ${displayValue}`, {
      x: margin + 10,
      y,
      size: 10,
      font: helvetica,
      color: rgb(0.1, 0.1, 0.1),
    });
    y -= lineHeight;
  };

  // Helper: draw multiline text
  const drawMultiline = (
    label: string,
    value: string | null | undefined,
    maxWidth = 500
  ) => {
    drawField(label, "");
    y += lineHeight; // Undo the field's line decrement
    y -= 4;

    const text = value ?? "N/A";
    const words = text.split(" ");
    let line = "";
    const charWidth = 5; // Approximate

    for (const word of words) {
      const testLine = line + (line ? " " : "") + word;
      if (testLine.length * charWidth > maxWidth) {
        page.drawText(line, {
          x: margin + 10,
          y,
          size: 9,
          font: helvetica,
          color: rgb(0.2, 0.2, 0.2),
        });
        y -= lineHeight - 2;
        line = word;
      } else {
        line = testLine;
      }
    }
    if (line) {
      page.drawText(line, {
        x: margin + 10,
        y,
        size: 9,
        font: helvetica,
        color: rgb(0.2, 0.2, 0.2),
      });
      y -= lineHeight;
    }
  };

  // Title
  page.drawText("CORRECTIVE ACTION FORM", {
    x: margin,
    y,
    size: 16,
    font: helveticaBold,
    color: rgb(0, 0, 0),
  });
  y -= 8;
  page.drawText("Document No. 2015-013", {
    x: margin,
    y,
    size: 9,
    font: helvetica,
    color: rgb(0.4, 0.4, 0.4),
  });
  y -= sectionGap + 10;

  // LOCATION DETAIL
  drawHeader("LOCATION DETAIL:");
  drawField("Permittee Name", ca.organization?.name);
  drawField(
    "County, State",
    [ca.county, ca.state].filter(Boolean).join(", ") || null
  );
  drawField("NPDES #", ca.permit?.permit_number);
  drawField("SMCRA #", ca.smcra_permit_number);
  drawField("Site # / Name", ca.site?.name);
  y -= sectionGap;

  // INCIDENT DETAIL
  drawHeader("INCIDENT DETAIL:");
  drawMultiline("Description of Incident / Agency Action Taken", ca.description);
  y -= 4;
  drawField("Date Issued", ca.date_issued);
  drawField("Date Received", ca.date_received);
  drawField("Issuing Person / Agency", ca.issuing_agency);
  drawField("Issued to", ca.issued_to);
  drawField("Regulation Cited", ca.regulation_cited);
  y -= sectionGap;

  // INCIDENT FOLLOW UP
  drawHeader("INCIDENT FOLLOW UP:");
  const followupName = ca.followup_user
    ? [ca.followup_user.first_name, ca.followup_user.last_name]
        .filter(Boolean)
        .join(" ") || null
    : null;
  drawField("Follow up assigned to", followupName);
  y -= 4;
  drawMultiline(
    "Event(s)/procedure(s) that caused/contributed to the incident",
    ca.contributing_factors
  );
  drawMultiline("Root Cause", ca.root_cause);
  drawMultiline("Immediate Mitigation/Abatement/Remedial Measures", ca.immediate_mitigation);
  drawMultiline("Long Term Corrective / Preventive Action Taken", ca.preventive_action);
  drawMultiline(
    "Documents requiring revision as a result of this action",
    ca.documents_requiring_revision
  );
  drawMultiline("Effectiveness of the action taken", ca.effectiveness_assessment);
  y -= sectionGap;

  // Signatures
  drawHeader("ACTION CLOSED:");
  y -= 4;

  const respName = ca.responsible_person
    ? [ca.responsible_person.first_name, ca.responsible_person.last_name]
        .filter(Boolean)
        .join(" ") || "_______________________"
    : "_______________________";
  const respDate = ca.responsible_person_signed_at
    ? ca.responsible_person_signed_at.split("T")[0]
    : "_____________";

  page.drawText(`${respName}`, { x: margin + 10, y, size: 10, font: helvetica });
  page.drawText(respDate, { x: 350, y, size: 10, font: helvetica });
  y -= lineHeight;
  page.drawText("Responsible Person", {
    x: margin + 10,
    y,
    size: 8,
    font: helvetica,
    color: rgb(0.5, 0.5, 0.5),
  });
  page.drawText("Date", {
    x: 350,
    y,
    size: 8,
    font: helvetica,
    color: rgb(0.5, 0.5, 0.5),
  });
  y -= lineHeight + 8;

  const apprName = ca.approved_by
    ? [ca.approved_by.first_name, ca.approved_by.last_name]
        .filter(Boolean)
        .join(" ") || "_______________________"
    : "_______________________";
  const apprDate = ca.approved_by_signed_at
    ? ca.approved_by_signed_at.split("T")[0]
    : "_____________";

  page.drawText(`${apprName}`, { x: margin + 10, y, size: 10, font: helvetica });
  page.drawText(apprDate, { x: 350, y, size: 10, font: helvetica });
  y -= lineHeight;
  page.drawText("Approved by", {
    x: margin + 10,
    y,
    size: 8,
    font: helvetica,
    color: rgb(0.5, 0.5, 0.5),
  });
  page.drawText("Date", {
    x: 350,
    y,
    size: 8,
    font: helvetica,
    color: rgb(0.5, 0.5, 0.5),
  });

  // Footer
  page.drawText("Distribution:", { x: margin, y: 80, size: 9, font: helveticaBold });
  page.drawText("Attach additional documentation, as needed", {
    x: margin,
    y: 68,
    size: 8,
    font: helvetica,
    color: rgb(0.4, 0.4, 0.4),
  });

  // Disclaimer
  page.drawText(DISCLAIMER_ONELINER, {
    x: margin,
    y: 30,
    size: 6,
    font: helvetica,
    color: rgb(0.5, 0.5, 0.5),
  });

  // Document number and date
  const genDate = new Date().toISOString().split("T")[0];
  page.drawText(`Document No. 2015-013 | Rev 01 | Generated ${genDate}`, {
    x: margin,
    y: 20,
    size: 7,
    font: helvetica,
    color: rgb(0.6, 0.6, 0.6),
  });

  return doc.save();
}

// ---------------------------------------------------------------------------
// Main handler
// ---------------------------------------------------------------------------
serve(async (req: Request) => {
  // CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  if (req.method !== "POST") {
    return new Response(JSON.stringify({ error: "Method not allowed" }), {
      status: 405,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }

  const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

  // Verify auth
  const { userId, orgId } = await verifyAuth(req, supabase);
  if (!userId) {
    return new Response(JSON.stringify({ error: "Unauthorized" }), {
      status: 401,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }

  // Parse request
  let body: { corrective_action_id?: string };
  try {
    body = await req.json();
  } catch {
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }

  const { corrective_action_id } = body;
  if (!corrective_action_id) {
    return new Response(
      JSON.stringify({ error: "corrective_action_id required" }),
      {
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  }

  // Fetch CA record
  const ca = await fetchCorrectiveAction(supabase, corrective_action_id);
  if (!ca) {
    return new Response(
      JSON.stringify({ error: "Corrective action not found" }),
      {
        status: 404,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  }

  // Verify user has access to this CA's org
  // CRITICAL: Must check even if orgId is null (prevents auth bypass)
  if (!orgId || ca.organization_id !== orgId) {
    return new Response(
      JSON.stringify({ error: "Access denied to this corrective action" }),
      {
        status: 403,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  }

  try {
    // Generate PDF
    const pdfBytes = await generatePdf(ca);

    // Upload to storage - use verified orgId from auth, not ca.organization_id
    // This prevents cross-org storage writes if RLS is bypassed
    const fileName = `CA-${ca.id.slice(0, 8).toUpperCase()}-${
      new Date().toISOString().split("T")[0]
    }.pdf`;
    const storagePath = `corrective-actions/${orgId}/${fileName}`;

    const { error: uploadError } = await supabase.storage
      .from("compliance-docs")
      .upload(storagePath, pdfBytes, {
        contentType: "application/pdf",
        upsert: true,
      });

    if (uploadError) {
      console.error("[generate-ca-pdf] Upload error:", uploadError.message);
      return new Response(
        JSON.stringify({ error: `Upload failed: ${uploadError.message}` }),
        {
          status: 500,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }

    // Update CA record
    const { error: updateError } = await supabase
      .from("corrective_actions")
      .update({
        generated_pdf_path: storagePath,
        generated_pdf_at: new Date().toISOString(),
      })
      .eq("id", corrective_action_id);

    if (updateError) {
      console.warn(
        "[generate-ca-pdf] Failed to update CA record:",
        updateError.message
      );
    }

    // Audit log (fire-and-forget, don't block on failure)
    try {
      await supabase.from("audit_log").insert({
        user_id: userId,
        organization_id: orgId, // Use verified orgId from auth
        action: "corrective_action_pdf_generated",
        module: "corrective_actions",
        table_name: "corrective_actions",
        record_id: corrective_action_id,
        description: JSON.stringify({ pdf_path: storagePath }),
        created_at: new Date().toISOString(),
      });
    } catch (auditErr) {
      console.warn("[generate-ca-pdf] Audit log failed:", auditErr);
    }

    return new Response(
      JSON.stringify({
        success: true,
        pdf_path: storagePath,
        file_name: fileName,
      }),
      {
        status: 200,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  } catch (err) {
    const message = err instanceof Error ? err.message : "PDF generation failed";
    console.error("[generate-ca-pdf] Error:", message);
    return new Response(JSON.stringify({ error: message }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
});
