import { useCallback, useState } from 'react';
import { toast } from 'sonner';
import { supabase } from '@/lib/supabase';
import { useAuditLog } from '@/hooks/useAuditLog';
import type { RoadmapTask, RoadmapStatus } from '@/types/roadmap';
import { PHASE_LABELS, STATUS_LABELS, OWNER_LABELS } from '@/types/roadmap';

export type ExportFormat = 'markdown' | 'csv';

interface ExportOptions {
  format: ExportFormat;
  includeNotes?: boolean;
  includeEvidence?: boolean;
  filterPhase?: number;
  filterOwner?: string;
  filterStatus?: RoadmapStatus;
}

interface PhaseStats {
  total: number;
  complete: number;
  inProgress: number;
  blocked: number;
  notStarted: number;
  na: number;
}

const DISCLAIMER =
  'Generated by SCC Compliance Monitor â€” a compliance reporting tool. Not an EMS. Not legal or environmental consulting. All data and reports require independent verification by qualified personnel before regulatory submission.';

export function useExportReport() {
  const { log } = useAuditLog();
  const [isExporting, setIsExporting] = useState(false);

  const fetchTasks = useCallback(async (): Promise<RoadmapTask[]> => {
    const { data, error } = await supabase
      .from('roadmap_tasks')
      .select('*')
      .order('task_id', { ascending: true });

    if (error) {
      throw new Error(`Failed to fetch tasks: ${error.message}`);
    }

    return (data ?? []) as RoadmapTask[];
  }, []);

  const calculatePhaseStats = useCallback((tasks: RoadmapTask[], phase: number): PhaseStats => {
    const phaseTasks = tasks.filter((t) => t.phase === phase);
    return {
      total: phaseTasks.length,
      complete: phaseTasks.filter((t) => t.status === 'complete').length,
      inProgress: phaseTasks.filter((t) => t.status === 'in_progress').length,
      blocked: phaseTasks.filter((t) => t.status === 'blocked').length,
      notStarted: phaseTasks.filter((t) => t.status === 'not_started').length,
      na: phaseTasks.filter((t) => t.status === 'na').length,
    };
  }, []);

  const generateMarkdown = useCallback(
    (tasks: RoadmapTask[], options: ExportOptions): string => {
      const now = new Date().toISOString().split('T')[0];
      const lines: string[] = [];

      // Header
      lines.push('# SCC Compliance Roadmap Status Report');
      lines.push(`**Generated:** ${now}`);
      lines.push('');

      // Executive Summary
      const totalTasks = tasks.length;
      const completeTasks = tasks.filter((t) => t.status === 'complete').length;
      const blockedTasks = tasks.filter((t) => t.status === 'blocked').length;
      const pct = Math.round((completeTasks / totalTasks) * 100);

      lines.push('## Executive Summary');
      lines.push('');
      lines.push(`- **Total Tasks:** ${totalTasks}`);
      lines.push(`- **Completed:** ${completeTasks} (${pct}%)`);
      lines.push(`- **In Progress:** ${tasks.filter((t) => t.status === 'in_progress').length}`);
      lines.push(`- **Blocked:** ${blockedTasks}`);
      lines.push(`- **Not Started:** ${tasks.filter((t) => t.status === 'not_started').length}`);
      lines.push('');

      if (blockedTasks > 0) {
        lines.push('### âš ï¸ Blocked Tasks');
        lines.push('');
        tasks
          .filter((t) => t.status === 'blocked')
          .forEach((t) => {
            lines.push(`- **${t.task_id}:** ${t.task_description}`);
            if (t.notes) {
              lines.push(`  - _Notes:_ ${t.notes}`);
            }
          });
        lines.push('');
      }

      // Phase-by-phase breakdown
      const phases = [...new Set(tasks.map((t) => t.phase))].sort((a, b) => a - b);

      for (const phase of phases) {
        if (options.filterPhase && options.filterPhase !== phase) continue;

        const stats = calculatePhaseStats(tasks, phase);
        const phaseName = PHASE_LABELS[phase] || `Phase ${phase}`;
        const phasePct = Math.round((stats.complete / stats.total) * 100);

        lines.push(`## ${phaseName}`);
        lines.push('');
        lines.push(`**Progress:** ${stats.complete}/${stats.total} tasks complete (${phasePct}%)`);
        lines.push('');

        const phaseTasks = tasks.filter((t) => t.phase === phase);

        // Group by section
        const sections = [...new Set(phaseTasks.map((t) => t.section))];

        for (const section of sections) {
          const sectionTasks = phaseTasks.filter((t) => t.section === section);
          lines.push(`### ${section}`);
          lines.push('');

          for (const task of sectionTasks) {
            if (options.filterStatus && task.status !== options.filterStatus) continue;
            if (options.filterOwner && task.owner_type !== options.filterOwner) continue;

            const statusEmoji =
              task.status === 'complete'
                ? 'âœ…'
                : task.status === 'in_progress'
                  ? 'ðŸ”„'
                  : task.status === 'blocked'
                    ? 'ðŸš«'
                    : 'â¬œ';
            const owner = OWNER_LABELS[task.owner_type] || task.owner_type;

            lines.push(`- ${statusEmoji} **${task.task_id}:** ${task.task_description}`);
            lines.push(`  - Owner: ${owner} | Status: ${STATUS_LABELS[task.status]}`);

            if (options.includeNotes && task.notes) {
              lines.push(`  - Notes: ${task.notes}`);
            }

            if (options.includeEvidence && task.evidence_paths && task.evidence_paths.length > 0) {
              lines.push(`  - Evidence: ${task.evidence_paths.join(', ')}`);
            }

            if (task.completed_at) {
              lines.push(`  - Completed: ${task.completed_at.split('T')[0]}`);
            }
          }
          lines.push('');
        }
      }

      // Pending Items by Owner
      lines.push('## Pending Items by Owner');
      lines.push('');

      const ownerTypes = [...new Set(tasks.map((t) => t.owner_type))];
      for (const owner of ownerTypes) {
        const ownerTasks = tasks.filter(
          (t) => t.owner_type === owner && t.status !== 'complete' && t.status !== 'na'
        );
        if (ownerTasks.length === 0) continue;

        const ownerLabel = OWNER_LABELS[owner] || owner;
        lines.push(`### ${ownerLabel} (${ownerTasks.length} pending)`);
        lines.push('');

        ownerTasks.forEach((t) => {
          lines.push(`- **${t.task_id}:** ${t.task_description} [${STATUS_LABELS[t.status]}]`);
        });
        lines.push('');
      }

      // Footer
      lines.push('---');
      lines.push('');
      lines.push(`_${DISCLAIMER}_`);

      return lines.join('\n');
    },
    [calculatePhaseStats]
  );

  const generateCSV = useCallback((tasks: RoadmapTask[], options: ExportOptions): string => {
    const headers = [
      'Task ID',
      'Phase',
      'Section',
      'Description',
      'Owner',
      'Status',
      'Assigned To',
      'Depends On',
      'Completed At',
    ];

    if (options.includeNotes) {
      headers.push('Notes');
    }
    if (options.includeEvidence) {
      headers.push('Evidence');
    }

    const rows: string[][] = [headers];

    for (const task of tasks) {
      if (options.filterPhase && task.phase !== options.filterPhase) continue;
      if (options.filterStatus && task.status !== options.filterStatus) continue;
      if (options.filterOwner && task.owner_type !== options.filterOwner) continue;

      const row = [
        task.task_id,
        String(task.phase),
        task.section,
        task.task_description.replace(/"/g, '""'),
        OWNER_LABELS[task.owner_type] || task.owner_type,
        STATUS_LABELS[task.status],
        task.assigned_to || '',
        task.depends_on?.join('; ') || '',
        task.completed_at?.split('T')[0] || '',
      ];

      if (options.includeNotes) {
        row.push((task.notes || '').replace(/"/g, '""'));
      }
      if (options.includeEvidence) {
        row.push(task.evidence_paths?.join('; ') || '');
      }

      rows.push(row);
    }

    // Convert to CSV string
    const csvContent = rows.map((row) => row.map((cell) => `"${cell}"`).join(',')).join('\n');

    return csvContent + `\n\n"${DISCLAIMER}"`;
  }, []);

  const downloadFile = useCallback((content: string, filename: string, mimeType: string) => {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }, []);

  const exportReport = useCallback(
    async (options: ExportOptions): Promise<void> => {
      setIsExporting(true);

      try {
        const tasks = await fetchTasks();
        const now = new Date().toISOString().split('T')[0];

        let content: string;
        let filename: string;
        let mimeType: string;

        if (options.format === 'markdown') {
          content = generateMarkdown(tasks, options);
          filename = `scc-roadmap-report-${now}.md`;
          mimeType = 'text/markdown;charset=utf-8';
        } else {
          content = generateCSV(tasks, options);
          filename = `scc-roadmap-report-${now}.csv`;
          mimeType = 'text/csv;charset=utf-8';
        }

        downloadFile(content, filename, mimeType);

        log('roadmap_report_exported', {
          format: options.format,
          task_count: tasks.length,
          filters: {
            phase: options.filterPhase,
            owner: options.filterOwner,
            status: options.filterStatus,
          },
        });

        toast.success(`Report exported as ${filename}`);
      } catch (err) {
        console.error('[useExportReport] Export failed:', err);
        toast.error('Failed to export report');
      } finally {
        setIsExporting(false);
      }
    },
    [fetchTasks, generateMarkdown, generateCSV, downloadFile, log]
  );

  return {
    exportReport,
    isExporting,
  };
}
